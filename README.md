Дополнительные 3 балла
В общем, мы подумали и я решил. В конце семестра у вас была тема, которая никак не затрагивались на практике, а именно алгоритмы кодирования. Поэтому задачка следующая: реализовать условное (от англ. conditional) кодирование Хаффмана с памятью 1.  (Чуть-чуть информации про это есть тут (https://iphome.hhi.de/schwarz/assets/pdfs/02_HuffmanCoding.pdf) на слайде 89, но в целом это отдано вам на самостоятельный разбор)

Что собственно нужно сделать:
1) Написать программку на вашем любимом языке программирования, которая будет уметь делать две штуки: кодировать заданный файл, и записывать результат кодирования в другой файл, и раскодировать уже закодированный файл обратно (естественно, чтобы он совпал с исходным).
2) Взять какой-нибудь текст на английском языке, размером хотя бы 100 КБ, посчитать для него энтропию и минимально возможный размер закодированного сообщения при энтропийном кодировании
3) Прислать мне в виде отчёта, в котором будет исходный код в читаемом виде (либо вставка в отформатированном виде, либо ссылка на гитхаб/условный pastebin), ссылка на выбранный файл для кодирования файл, расчёт энтропии и минимальной длины, описание работы алгоритма на русском языке, а также скомпиленная программа в stand-alone .exe-файл (то бишь чтоб оно спокойно запустилось у меня, не ругаясь на отсуствие каких-то библиотек или что-то ещё).

Задание намеренно сделано не самым тривиальным, чтоб ни у кого не было мысли тупо скатать готовый код из интернета, и чтоб это не было просто "халявные три балла лишь бы не идти на экзамен".

Дедлайн: 21 января в 12:00

6. Про запись на защиту
   Просьба обратить внимание на слова "Во-вторых, записываемся подряд, без пробелов... Я не хочу принять одного человека, а потом сидеть ждать второго час...". Если я приму очередного человека, и увижу, что никто не хочет идти следующим, сдача в этот день на этом закончится.
7. У тебя вероятность по всем символам не общая, а в зависимости от предыдущего символа. То есть условно, после символа 'а' у тебя такие-то вероятности, после символа 'b' другие. Соответственно, у тебя будет не одно дерево Хаффмана, а по числу символов в алфавите, и по какому дереву тот или иной код будет расшифровываться, будет зависеть от того, какой символ шёл перед ним.